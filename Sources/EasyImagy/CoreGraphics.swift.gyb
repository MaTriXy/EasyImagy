% uint_types = ['UInt8', 'UInt16']
% float_types = ['Float', 'Double']
% type_to_additive = {
%   'UInt8' : 'Int',
%   'UInt16': 'Int',
% }
%
#if canImport(CoreGraphics)
import CoreGraphics

public enum CGContextCoordinates {
    case original
    case natural
}

public protocol _CGGrayScale {}
public protocol _CGRGBA {}

extension _CGGrayScale {
    public static var _ez_cgColorSpace: CGColorSpace {
        return CGColorSpaceCreateDeviceGray()
    }

    public static var _ez_cgBitmapInfo: CGBitmapInfo {
        return CGBitmapInfo()
    }
}

extension _CGRGBA {
    public static var _ez_cgColorSpace: CGColorSpace {
        return CGColorSpaceCreateDeviceRGB()
    }

    public static var _ez_cgBitmapInfo: CGBitmapInfo {
        return CGBitmapInfo(rawValue: CGImageAlphaInfo.premultipliedLast.rawValue | CGBitmapInfo.byteOrder32Big.rawValue)
    }
}

extension UInt8: _CGGrayScale {}
extension UInt16: _CGGrayScale {}
extension Float: _CGGrayScale {}
extension Double: _CGGrayScale {}
extension Bool: _CGGrayScale {}
extension RGBA: _CGRGBA {}
extension PremultipliedRGBA: _CGRGBA {}

public protocol _CGChannel {
    associatedtype _EZ_DirectChannel: _CGDirectChannel, Numeric
}

public protocol _CGDirectChannel: _CGChannel where _EZ_DirectChannel == Self {

}

extension UInt8: _CGDirectChannel {
    public typealias _EZ_DirectChannel = UInt8
}

extension UInt16: _CGDirectChannel {
    public typealias _EZ_DirectChannel = UInt16
}

extension Float: _CGChannel {
    public typealias _EZ_DirectChannel = UInt8
}

extension Double: _CGChannel {
    public typealias _EZ_DirectChannel = UInt8
}

extension Bool: _CGChannel {
    public typealias _EZ_DirectChannel = UInt8
}

public protocol _CGPixel {
    associatedtype _EZ_DirectPixel: _CGDirectPixel
    associatedtype _EZ_PixelDirectChannel: _CGDirectChannel

    static var _ez_cgColorSpace: CGColorSpace { get }
    static var _ez_cgBitmapInfo: CGBitmapInfo { get }
}

public protocol _CGDirectPixel: _CGPixel where _EZ_DirectPixel == Self {

}

extension UInt8: _CGDirectPixel {
    public typealias _EZ_DirectPixel = UInt8
    public typealias _EZ_PixelDirectChannel = UInt8
}

extension UInt16: _CGDirectPixel {
    public typealias _EZ_DirectPixel = UInt16
    public typealias _EZ_PixelDirectChannel = UInt16
}

extension Float: _CGPixel {
    public typealias _EZ_DirectPixel = UInt8
    public typealias _EZ_PixelDirectChannel = UInt8
}

extension Double: _CGPixel {
    public typealias _EZ_DirectPixel = UInt8
    public typealias _EZ_PixelDirectChannel = UInt8
}

extension Bool: _CGPixel {
    public typealias _EZ_DirectPixel = UInt8
    public typealias _EZ_PixelDirectChannel = UInt8
}

extension RGBA: _CGPixel where Channel: _CGChannel {
    public typealias _EZ_DirectPixel = PremultipliedRGBA<Channel._EZ_DirectChannel>
    public typealias _EZ_PixelDirectChannel = Channel._EZ_DirectChannel
}

extension PremultipliedRGBA: _CGPixel where Channel: _CGChannel {
    public typealias _EZ_DirectPixel = PremultipliedRGBA<Channel._EZ_DirectChannel>
    public typealias _EZ_PixelDirectChannel = Channel._EZ_DirectChannel
}

extension PremultipliedRGBA: _CGDirectPixel where Channel: _CGDirectChannel {

}

extension Image where Pixel: _CGDirectPixel {
    public mutating func withCGContext(coordinates: CGContextCoordinates = .natural, _ body: (CGContext) throws -> Void) rethrows {
        let width = self.width
        let height = self.height

        precondition(width >= 0)
        precondition(height >= 0)

        let context  = CGContext(
            data: &pixels,
            width: width,
            height: height,
            bitsPerComponent: MemoryLayout<Pixel._EZ_PixelDirectChannel>.size * 8,
            bytesPerRow: MemoryLayout<Pixel>.size * width,
            space: Pixel._ez_cgColorSpace,
            bitmapInfo: Pixel._ez_cgBitmapInfo.rawValue
        )!
        switch coordinates {
        case .original:
            break
        case .natural:
            context.scaleBy(x: 1, y: -1)
            context.translateBy(x: 0.5, y: 0.5 - CGFloat(height))
        }

        try body(context)
    }
}
% for type in uint_types:
%   additive = type_to_additive[type]

extension Image where Pixel == RGBA<${type}> {
    private init(width: Int, height: Int, setUp: (CGContext) -> ()) {
        let image = Image<PremultipliedRGBA<${type}>>(width: width, height: height, setUp: setUp)
        self = image.map { RGBA<${type}>($0) }
    }
    
    public init(cgImage: CGImage) {
        let width = cgImage.width
        let height = cgImage.height
        
        self.init(width: width, height: height, setUp: { context in
            let rect = CGRect(x: 0.0, y: 0.0, width: CGFloat(width), height: CGFloat(height))
            context.draw(cgImage, in: rect)
        })
    }
    
    public var cgImage: CGImage {
        return Image.generatedCGImage(
            image: self,
            colorSpace: Pixel._ez_cgColorSpace,
            bitmapInfo: Pixel._ez_cgBitmapInfo,
            maxValue: .max,
            toAdditive: ${additive}.init,
            product: (*) as (${additive}, ${additive}) -> ${additive},
            quotient: (/) as (${additive}, ${additive}) -> ${additive},
            toOriginal: ${type}.init
        )
    }
}
% end
%
% for type in float_types:

extension Image where Pixel == RGBA<${type}> {
    private init(width: Int, height: Int, setUp: (CGContext) -> ()) {
        let image = Image<PremultipliedRGBA<${type}>>(width: width, height: height, setUp: setUp)
        self = image.map { RGBA<${type}>($0) }
    }
    
    public init(cgImage: CGImage) {
        let width = cgImage.width
        let height = cgImage.height
        
        self.init(width: width, height: height, setUp: { context in
            let rect = CGRect(x: 0.0, y: 0.0, width: CGFloat(width), height: CGFloat(height))
            context.draw(cgImage, in: rect)
        })
    }
    
    public var cgImage: CGImage {
        return map { $0.map { UInt8(clamp($0, lower: 0.0, upper: 1.0) * 255) } }.cgImage
    }
}
% end

extension Image where Pixel == RGBA<Bool> {
    private init(width: Int, height: Int, setUp: (CGContext) -> ()) {
        let image = Image<RGBA<UInt8>>(width: width, height: height, setUp: setUp)
        self = image.map { $0.map { $0 >= 128 } }
    }
    
    public init(cgImage: CGImage) {
        let width = cgImage.width
        let height = cgImage.height
        
        self.init(width: width, height: height, setUp: { context in
            let rect = CGRect(x: 0.0, y: 0.0, width: CGFloat(width), height: CGFloat(height))
            context.draw(cgImage, in: rect)
        })
    }
    
    public var cgImage: CGImage {
        return map { $0.map { $0 ? (255 as UInt8) : (0 as UInt8) } }.cgImage
    }
}
%
% for type in uint_types:

extension Image where Pixel == PremultipliedRGBA<${type}> {
    private init(width: Int, height: Int, setUp: (CGContext) -> ()) {
        let pixels = [PremultipliedRGBA<${type}>](repeating: PremultipliedRGBA<${type}>(red: 0, green: 0, blue: 0, alpha: 0), count: width * height)
        self.init(width: width, height: height, pixels: pixels)
        withCGContext(coordinates: .original, setUp)
    }
    
    public init(cgImage: CGImage) {
        let width = cgImage.width
        let height = cgImage.height
        
        self.init(width: width, height: height, setUp: { context in
            let rect = CGRect(x: 0.0, y: 0.0, width: CGFloat(width), height: CGFloat(height))
            context.draw(cgImage, in: rect)
        })
    }
    
    public var cgImage: CGImage {
        return Image.generatedCGImage(
            image: self,
            colorSpace: Pixel._ez_cgColorSpace,
            bitmapInfo: Pixel._ez_cgBitmapInfo,
            componentType: ${type}.self
        )
    }

    public func withCGImage<R>(_ body: (CGImage) throws -> R) rethrows -> R {
        return try Image.withGeneratedCGImage(
            image: self,
            colorSpace: Pixel._ez_cgColorSpace,
            bitmapInfo: Pixel._ez_cgBitmapInfo,
            body: body,
            componentType: ${type}.self
        )
    }
}
% end
%
% for type in float_types:

extension Image where Pixel == PremultipliedRGBA<${type}> {
    private init(width: Int, height: Int, setUp: (CGContext) -> ()) {
        let image = Image<PremultipliedRGBA<UInt8>>(width: width, height: height, setUp: setUp)
        self = image.map { $0.map { ${type}($0) / 255 } }
    }
    
    public init(cgImage: CGImage) {
        let width = cgImage.width
        let height = cgImage.height
        
        self.init(width: width, height: height, setUp: { context in
            let rect = CGRect(x: 0.0, y: 0.0, width: CGFloat(width), height: CGFloat(height))
            context.draw(cgImage, in: rect)
        })
    }
    
    public var cgImage: CGImage {
        return map { $0.map { UInt8(clamp($0, lower: 0.0, upper: 1.0) * 255) } }.cgImage
    }
}
% end
%
% for type in uint_types:

extension Image where Pixel == ${type} {
    private init(width: Int, height: Int, setUp: (CGContext) -> ()) {
        let pixels = [${type}](repeating: .zero, count: width * height)
        self.init(width: width, height: height, pixels: pixels)
        withCGContext(coordinates: .original, setUp)
    }
    
    public init(cgImage: CGImage) {
        let width = cgImage.width
        let height = cgImage.height
        
        self.init(width: width, height: height, setUp: { context in
            let rect = CGRect(x: 0.0, y: 0.0, width: CGFloat(width), height: CGFloat(height))
            context.draw(cgImage, in: rect)
        })
    }
    
    public var cgImage: CGImage {
        return Image.generatedCGImage(
            image: self,
            colorSpace: Pixel._ez_cgColorSpace,
            bitmapInfo: Pixel._ez_cgBitmapInfo,
            componentType: ${type}.self
        )
    }

    public func withCGImage<R>(_ body: (CGImage) throws -> R) rethrows -> R {
        return try Image.withGeneratedCGImage(
            image: self,
            colorSpace: Pixel._ez_cgColorSpace,
            bitmapInfo: Pixel._ez_cgBitmapInfo,
            body: body,
            componentType: ${type}.self
        )
    }
}
% end
%
% for type in float_types:

extension Image where Pixel == ${type} {
    private init(width: Int, height: Int, setUp: (CGContext) -> ()) {
        let image = Image<UInt8>(width: width, height: height, setUp: setUp)
        self = image.map { ${type}($0) / 255 }
    }
    
    public init(cgImage: CGImage) {
        let width = cgImage.width
        let height = cgImage.height
        
        self.init(width: width, height: height, setUp: { context in
            let rect = CGRect(x: 0.0, y: 0.0, width: CGFloat(width), height: CGFloat(height))
            context.draw(cgImage, in: rect)
        })
    }
    
    public var cgImage: CGImage {
        return map { UInt8(clamp($0, lower: 0.0, upper: 1.0) * 255) }.cgImage
    }
}
% end

extension Image where Pixel == Bool {
    private init(width: Int, height: Int, setUp: (CGContext) -> ()) {
        let image = Image<UInt8>(width: width, height: height, setUp: setUp)
        self = image.map { $0 >= 128 }
    }
    
    public init(cgImage: CGImage) {
        let width = cgImage.width
        let height = cgImage.height
        
        self.init(width: width, height: height, setUp: { context in
            let rect = CGRect(x: 0.0, y: 0.0, width: CGFloat(width), height: CGFloat(height))
            context.draw(cgImage, in: rect)
        })
    }
    
    public var cgImage: CGImage {
        return map { $0 ? 255 as UInt8 : 0 as UInt8 }.cgImage
    }
}
%
% for type in uint_types:

extension ImageSlice where Pixel == PremultipliedRGBA<${type}> {
    public var cgImage: CGImage {
        return ImageSlice<PremultipliedRGBA<${type}>>.generatedCGImage(
            slice: self,
            colorSpace: Pixel._ez_cgColorSpace,
            bitmapInfo: Pixel._ez_cgBitmapInfo,
            componentType: ${type}.self
        )
    }

    public func withCGImage<R>(_ body: (CGImage) throws -> R) rethrows -> R {
        return try ImageSlice<PremultipliedRGBA<${type}>>.withGeneratedCGImage(
            slice: self,
            colorSpace: Pixel._ez_cgColorSpace,
            bitmapInfo: Pixel._ez_cgBitmapInfo,
            body: body,
            componentType: ${type}.self
        )
    }

    public mutating func withCGContext(coordinates: CGContextCoordinates = .natural, _ body: (CGContext) throws -> Void) rethrows {
        precondition(width >= 0)
        precondition(height >= 0)

        let data: UnsafeMutablePointer<PremultipliedRGBA<${type}>> = &self.image.pixels + (yRange.lowerBound * self.image.width + xRange.lowerBound)
        let context  = CGContext(
            data: data,
            width: width,
            height: height,
            bitsPerComponent: MemoryLayout<${type}>.size * 8,
            bytesPerRow: MemoryLayout<PremultipliedRGBA<${type}>>.size * self.image.width,
            space: Pixel._ez_cgColorSpace,
            bitmapInfo: Pixel._ez_cgBitmapInfo.rawValue
        )!
        switch coordinates {
        case .original:
            break
        case .natural:
            context.scaleBy(x: 1, y: -1)
            context.translateBy(x: 0.5 - CGFloat(xRange.lowerBound), y: 0.5 - CGFloat(yRange.lowerBound + height))
        }

        try body(context)
    }
}
% end
%
% for type in uint_types:

extension ImageSlice where Pixel == ${type} {
    public var cgImage: CGImage {
        return ImageSlice<${type}>.generatedCGImage(
            slice: self,
            colorSpace: Pixel._ez_cgColorSpace,
            bitmapInfo: Pixel._ez_cgBitmapInfo,
            componentType: ${type}.self
        )
    }

    public func withCGImage<R>(_ body: (CGImage) throws -> R) rethrows -> R {
        return try ImageSlice<${type}>.withGeneratedCGImage(
            slice: self,
            colorSpace: Pixel._ez_cgColorSpace,
            bitmapInfo: Pixel._ez_cgBitmapInfo,
            body: body,
            componentType: ${type}.self
        )
    }

    public mutating func withCGContext(coordinates: CGContextCoordinates = .natural, _ body: (CGContext) throws -> Void) rethrows {
        precondition(width >= 0)
        precondition(height >= 0)

        let data: UnsafeMutablePointer<${type}> = &self.image.pixels + (yRange.lowerBound * self.image.width + xRange.lowerBound)
        let context  = CGContext(
            data: data,
            width: width,
            height: height,
            bitsPerComponent: MemoryLayout<${type}>.size * 8,
            bytesPerRow: MemoryLayout<${type}>.size * self.image.width,
            space: Pixel._ez_cgColorSpace,
            bitmapInfo: Pixel._ez_cgBitmapInfo.rawValue
        )!
        switch coordinates {
        case .original:
            break
        case .natural:
            context.scaleBy(x: 1, y: -1)
            context.translateBy(x: 0.5 - CGFloat(xRange.lowerBound), y: 0.5 - CGFloat(yRange.lowerBound + height))
        }

        try body(context)
    }
}
% end
%
#endif
